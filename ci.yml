---
name: Platform CI Workflow
"on":
  workflow_call:
    inputs:
      oas-files:
        description: JSON array of file paths for OAS validation
        required: false
        type: string
      sonarqube-quality-gate:
        description: Check the Sonar Quality Gate status and fail the pipeline if QC not passed
        required: false
        type: boolean
        default: true
      security-sca:
        required: false
        default: false
        type: boolean
      security-sca-exclude-dirs:
        required: false
        type: string
        description: A comma-separated list of directories to exclude in SCA jobs
      security-snyk:
        required: false
        default: false
        type: boolean
        description: Enable Snyk security checks
    outputs:
      images-map:
        value: ${{ jobs.build-collect.outputs.container_modules }}
        description: A map of the built images
defaults:
  run:
    shell: bash
jobs:
  validate-yaml:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Validate YAML files
        run: >
          yamllint --config-data "{extends: relaxed, rules: {line-length: disable}, ignore: [charts/, templates/, .garden/, vendor/]}" .
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  validate-service-catalog:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Check out platform-github-action repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          repository: uniphore/platform-github-actions
          path: platform-github-actions
          submodules: false
          persist-credentials: false
      - name: Install Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.12
          cache: pip
          cache-dependency-path: platform-github-actions/.github/resources/datadog-service-catalog/requirements.txt
      - name: Install yamale
        run: pip install -r platform-github-actions/.github/resources/datadog-service-catalog/requirements.txt
      - name: Validate service.datadog.yaml against service-datadog-schema.yml
        run: |
          readonly SERVICE_CATALOG_FILE='service.datadog.yaml'
          readonly SERVICE_CATALOG_SCHEMA_FILE='platform-github-actions/.github/resources/datadog-service-catalog/service-datadog-schema.yml'

          if [[ -f "${SERVICE_CATALOG_FILE}" ]]; then
            yamale_output="$(yamale -s "${SERVICE_CATALOG_SCHEMA_FILE}" "${SERVICE_CATALOG_FILE}")" || fail=true
            echo "${yamale_output}"

            if [[ "${fail}" == true ]]; then
              echo "::WARNING::Service Catalog validation did not pass, see the validate-service-catalog job for more info."
            fi

          else
            echo "::WARNING::Service Catalog validation did not pass. ${SERVICE_CATALOG_FILE} is not found."
          fi
      - name: Validate dd-service value with template-service
        env:
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          readonly SERVICE_CATALOG_FILE=service.datadog.yaml
          readonly TEMPLATE_DD_SERVICE=(
            hello-world-go
            hello-world-py
            hello-world-java
          )
          declare -Ar TEMPLATE_REPOS=(
            [platform-hello-world-go]=true
            [platform-hello-world-py]=true
            [platform-hello-world-java]=true
          )

          if [[ -n "${TEMPLATE_REPOS[$REPO_NAME]}" ]]; then
            echo "Template repository detected. Skipping validation.."
            exit 0
          fi

          found_template_services=()
          for service in "${TEMPLATE_DD_SERVICE[@]}"; do
            if yq '.dd-service' "${SERVICE_CATALOG_FILE}" | grep -q "^${service}$"; then
              found_template_services+=("${service}")
            fi
          done

          if [[ "${#found_template_services[@]}" -gt 0 ]]; then
            echo "::ERROR::Found template services names in the DataDog ${SERVICE_CATALOG_FILE}: ${found_template_services[*]}. Please update the dd-service values"
            exit 1
          fi

          echo "Validation success!"
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  validate-collect-oas:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.files }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Collect files for OAS validation
        id: matrix
        env:
          OAS_FILES: ${{ inputs.oas-files }}
        run: |
          if [[ -n "${OAS_FILES}" ]]; then
            echo "files=${OAS_FILES}" >> "${GITHUB_OUTPUT}"
          else
            COLLECT_OAS_LOG="${RUNNER_TEMP}/collect_oas_${GITHUB_RUN_ID}.log"
            find . -type f -regextype posix-extended -iregex '.*[^a-zA-Z0-9]oas([^a-zA-Z0-9].*)?\.ya?ml' \
            | tee "${COLLECT_OAS_LOG}"
            {
              echo "files<<EOF"
              jq --raw-input --null-input '[inputs | select(length>0)]' < "${COLLECT_OAS_LOG}"
              echo "EOF"
            } >> "${GITHUB_OUTPUT}"
          fi
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  validate-oas:
    if: >
      needs.validate-collect-oas.outputs.matrix != '[]'
      && needs.validate-collect-oas.result == 'success'
      && !cancelled()
    needs: validate-collect-oas
    strategy:
      matrix:
        value: ${{ fromJson(needs.validate-collect-oas.outputs.matrix) }}
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Validate OpenAPI definition
        uses: char0n/apidom-validate@248675e12929bb9b55eff78e9f5ea1a0844a083d
        with:
          definition-file: ${{ matrix.value }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  validate-charts:
    runs-on: ubuntu-latest
    steps:
      - name: Install chartgardener
        uses: uniphore/platform-github-actions/.github/actions/setup-chartgardener@main
        with:
          github-token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Scan for tech stack
        uses: uniphore/platform-github-actions/.github/actions/detect-tech-stack@main
        id: stack
      - name: Validate charts
        if: steps.stack.outputs.chart == 'true'
        run: |
          if [[ ! -f chartgardener.yml ]]; then
            echo "::ERROR::chartgardener.yml file not found! Please check the hello-world templates for reference."
            exit 1
          fi

          CHARTGARDENER_LOG="${RUNNER_TEMP}/chartgardener_${GITHUB_RUN_ID}.log"
          chartgardener --action validate --log-level=INFO | tee "${CHARTGARDENER_LOG}" || fail=true

          while read -r severity && read -r message; do
            if [[ "${severity}" == 'WARNING' || "${severity}" == 'ERROR' ]]; then
              echo "::${severity}::${message}"
            fi
          done < <(awk -F' - ' '{print $3; print $4}' "${CHARTGARDENER_LOG}")

          if [[ "${fail}" == true ]]; then
            exit 1
          fi
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  validate-kyverno:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Check out kyverno-policies repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          repository: uniphore/kyverno-policies
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          path: kyverno-policies
      - name: Install Kyverno CLI
        uses: kyverno/action-install-cli@fcee92fca5c883169ef9927acf543e0b5fc58289
        with:
          release: v1.11.0
      - name: Scan for tech stack
        uses: uniphore/platform-github-actions/.github/actions/detect-tech-stack@main
        id: stack
      - name: Test chart against Kyverno Policies
        if: steps.stack.outputs.chart == 'true'
        run: |
          shopt -s extglob
          shopt -s nullglob

          POLICY_FILES="kyverno-policies/ci"

          app_dir="$(find charts -mindepth 1 -maxdepth 1 -type d)"
          if [[ "$(grep -c '' <<< "${app_dir}")" == 1 ]]; then
            app_name="$(yq .name "${app_dir}"/garden.y?(a)ml)"
          else
            app_name="$(yq .name project.garden.y?(a)ml)"
          fi

          helm template "./charts/${app_name}/" --values "charts/${app_name}/values.yaml" --output-dir "${RUNNER_TEMP}/helm-template"

          gate_pipeline=false

          #apply policy for the files
          apply_policy() {
            local policy_file="$1"
            local audit_option="$2"
            local failed=false
            echo "Kyverno policy file name with path : ${policy_file}"
            echo "validation Failure Action of kyvenro audit/enforce : ${audit_option}"
            kyverno apply --table -r "${RUNNER_TEMP}/helm-template/${app_name}/templates/" "${policy_file}" || failed=true
            if [[ "${failed}" == true ]]; then
              local policy_name
              policy_name="$(yq '.metadata.name' "${policy_file}")"
              if [[ "${audit_option}" == 'audit-warn' ]]; then
                echo "::WARNING::The chart did not pass the cluster policy: ${policy_name}. See the validate-kyverno job for more info."
              else
                echo "::ERROR::The chart did not pass the cluster policy: ${policy_name}. See the validate-kyverno job for more info."
                gate_pipeline=true
              fi
            fi
          }
          # Process each policy file
          for file in "${POLICY_FILES}"/*.y?(a)ml; do
            policy_filename="$(basename "${file}")"
            echo "Validating file : ${policy_filename}"
            unset audit
            if yq '.spec.validationFailureAction == "audit"' "${file}" >/dev/null 2>&1; then
              audit='audit-warn'
            else
              audit='enforce'
            fi
            apply_policy "${file}" "${audit}"
          done
          # Check if the pipeline should be gated
          if [[ "${gate_pipeline}" == true ]]; then
            exit 1
          fi
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  test-collect:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    outputs:
      tests: ${{ steps.tests.outputs.tests }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          submodules: false
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Set up Garden
        id: garden
        uses: uniphore/platform-github-actions/.github/actions/setup-garden@main
        with:
          aws-cluster-arn: ${{ vars.PLATFORM_CI_AWS_CLUSTER_ARN }}
          aws-iam-oidc-role-arn: ${{ vars.PLATFORM_CI_AWS_IAM_OIDC_ROLE_ARN }}
          aws-region: ${{ vars.PLATFORM_CI_AWS_REGION }}
          github-token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Collect test suites
        id: tests
        env:
          NAMESPACE: ${{ steps.garden.outputs.namespace }}
          GITHUB_PULL_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
        run: |
          readonly TEST_COLLECT_JSON="${RUNNER_TEMP}/test_collect_${GITHUB_RUN_ID}.json"

          garden get tests --env="${NAMESPACE}.ci" -o=json | tee "${TEST_COLLECT_JSON}"
          {
            echo "tests<<EOF"
            jq '.result.actions[].name' < "${TEST_COLLECT_JSON}" | jq --slurp
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  test-run:
    if: >
      needs.test-collect.outputs.tests != '[]'
      && needs.test-collect.result == 'success'
      && !cancelled()
    needs: test-collect
    strategy:
      matrix:
        test-suite: ${{ fromJson(needs.test-collect.outputs.tests) }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          submodules: true
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Set up Garden
        id: garden
        uses: uniphore/platform-github-actions/.github/actions/setup-garden@main
        with:
          aws-cluster-arn: ${{ vars.PLATFORM_CI_AWS_CLUSTER_ARN }}
          aws-iam-oidc-role-arn: ${{ vars.PLATFORM_CI_AWS_IAM_OIDC_ROLE_ARN }}
          aws-region: ${{ vars.PLATFORM_CI_AWS_REGION }}
          github-token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          namespace-key: ${{ matrix.test-suite }}
      - name: Set up test environment
        uses: uniphore/platform-github-actions/.github/actions/setup-env@main
        with:
          github-token: ${{ secrets.platform_ci_github_pull_token }}
          github-pkg-token: ${{ secrets.platform_ci_github_packages_pull_token }}
          registry: ${{ vars.platform_registry_host_url }}
          registry-username: ${{ vars.platform_registry_read_only_user }}
          registry-password: ${{ secrets.platform_registry_read_only_pwd }}
          chart-login: true
      - name: Run ${{ matrix.test-suite }} tests
        id: test
        env:
          TEST_SUITE: ${{ matrix.test-suite }}
          NAMESPACE: ${{ steps.garden.outputs.namespace }}
          GITHUB_PULL_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          GITHUB_PKG_PULL_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PACKAGES_PULL_TOKEN }}
        run: garden test "${TEST_SUITE}" --force --env="${NAMESPACE}.ci" --show-timestamps
      - name: Save test reports
        uses: actions/upload-artifact@v4
        with:
          name: test-reports-${{ matrix.test-suite }}
          path: .garden/artifacts/test-reports/
          retention-days: 30
      - name: Save Garden error logs (if any) as an artifact
        if: always() && steps.test.outcome == 'failure'
        uses: uniphore/platform-github-actions/.github/actions/garden-log@main
        with:
          filename-suffix: ${{ matrix.test-suite }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 300
  build-collect:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    outputs:
      container_modules: ${{ steps.collect.outputs.container_modules }}
      container_modules_names: ${{ steps.collect.outputs.container_modules_names }}
      container_modules_ids: ${{ steps.collect.outputs.container_modules_ids }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          submodules: true
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Set up Garden
        id: garden
        uses: uniphore/platform-github-actions/.github/actions/setup-garden@main
        with:
          aws-cluster-arn: ${{ vars.PLATFORM_CI_AWS_CLUSTER_ARN }}
          aws-iam-oidc-role-arn: ${{ vars.PLATFORM_CI_AWS_IAM_OIDC_ROLE_ARN }}
          aws-region: ${{ vars.PLATFORM_CI_AWS_REGION }}
          github-token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Collect images to build
        id: collect
        env:
          NAMESPACE: ${{ steps.garden.outputs.namespace }}
          GITHUB_PULL_TOKEN: ${{ secrets.platform_ci_github_pull_token }}
        run: |
          build_collect_json="${RUNNER_TEMP}/build_collect_${GITHUB_RUN_ID}.json"

          echo "::group::garden get modules"
          garden get modules --exclude-disabled --env="${NAMESPACE}.build" -o=json > "${build_collect_json}"
          cat "${build_collect_json}"
          echo "::endgroup::"

          CONTAINER_MODULES="$(
            jq '[
                  .result.modules[]
                  | select(.type | endswith("container"))
                  | select(.path | contains(".garden/sources") | not)
                  | {(.name): .outputs["deployment-image-id"]}
                ] | add // {}' < "${build_collect_json}"
          )"
          CONTAINER_MODULES_NAMES="$(jq 'keys' <<< "${CONTAINER_MODULES}")"
          CONTAINER_MODULES_IDS="$(jq '[.[]]' <<< "${CONTAINER_MODULES}")"

          {
            echo "container_modules<<EOF"
            echo "${CONTAINER_MODULES}"
            echo "EOF"
            echo "container_modules_names<<EOF"
            echo "${CONTAINER_MODULES_NAMES}"
            echo "EOF"
            echo "container_modules_ids<<EOF"
            echo "${CONTAINER_MODULES_IDS}"
            echo "EOF"
          } >> "${GITHUB_OUTPUT}"
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  build-image:
    if: >
      needs.build-collect.outputs.container_modules_names != '[]'
      && needs.build-collect.result == 'success'
      && !cancelled()
    needs: build-collect
    strategy:
      matrix:
        module: ${{ fromJson(needs.build-collect.outputs.container_modules_names) }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          submodules: true
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Set up Garden
        id: garden
        uses: uniphore/platform-github-actions/.github/actions/setup-garden@main
        with:
          aws-cluster-arn: ${{ vars.PLATFORM_CI_AWS_CLUSTER_ARN }}
          aws-iam-oidc-role-arn: ${{ vars.PLATFORM_CI_AWS_IAM_OIDC_ROLE_ARN }}
          aws-region: ${{ vars.PLATFORM_CI_AWS_REGION }}
          github-token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          namespace-key: ${{ matrix.module }}
      - name: Set up build environment
        uses: uniphore/platform-github-actions/.github/actions/setup-env@main
        with:
          github-token: ${{ secrets.platform_ci_github_pull_token }}
          github-pkg-token: ${{ secrets.platform_ci_github_packages_pull_token }}
          registry: ${{ vars.platform_registry_host_url }}
          registry-username: ${{ vars.platform_registry_user }}
          registry-password: ${{ secrets.platform_registry_pwd }}
      - name: Build ${{ matrix.module }} image
        id: build
        env:
          CONTAINER_MODULE_NAME: ${{ matrix.module }}
          NAMESPACE: ${{ steps.garden.outputs.namespace }}
          GITHUB_PULL_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          GITHUB_PKG_PULL_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PACKAGES_PULL_TOKEN }}
        run: garden build "${CONTAINER_MODULE_NAME}" --env="${NAMESPACE}.build" --show-timestamps
      - name: Save Garden error logs (if any) as an artifact
        if: always() && steps.build.outcome == 'failure'
        uses: uniphore/platform-github-actions/.github/actions/garden-log@main
        with:
          filename-suffix: ${{ matrix.module }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 300
  security-chainguard:
    runs-on: ubuntu-latest
    outputs:
      integrated: ${{ steps.chainguard.outputs.integrated }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Check for Chainguard integration
        id: chainguard
        run: |
          MESSAGE="Make use of chainguard images in the mentioned file to \
          protect against vulnerabilities and ensure reliable, safe \
          deployments. You can find the appropriate chainguard image \
          for integration at the following links: \
          https://edu.chainguard.dev/chainguard/chainguard-images/reference/ and \
          https://registry.uniphore.com/harbor/projects/39"

          # Find all Dockerfile, pom.xml and build.gradle files
          readarray -t files < <(
            find . -type f -name "pom.xml" -or -name "build*.gradle" -or -name "*Dockerfile*"
          )

          # Searching for Chainguard integration
          for file in "${files[@]}"; do
            if grep -qE '(registry.uniphore.com/chainguard|cgr.dev/chainguard)' "${file}"; then
              echo "Chainguard is installed in ${file}"
              echo "integrated=true" >> "${GITHUB_OUTPUT}"
            else
              echo "::WARNING file=${file}::${MESSAGE}"
            fi
          done
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  security-sca:
    if: >
      needs.build-image.result == 'success'
      && needs.build-collect.result == 'success'
      && needs.build-collect.outputs.container_modules_ids != '[]'
      && !cancelled()
    needs: [build-collect, build-image]
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.build-collect.outputs.container_modules_ids) }}
    runs-on: ubuntu-latest
    steps:
      - name: Generate report file name
        id: report-filename
        env:
          IMAGE_ID: ${{ matrix.image }}
        run: |
          image="${IMAGE_ID##*/}"
          image="${image//:/-}"
          echo "name=sca-report-${image}.txt" >> "${GITHUB_OUTPUT}"
      - name: Run SCA scan
        id: scan
        uses: aquasecurity/trivy-action@1a09192c0ea4a3f42a25d6ebc3abc423c2601f1a
        with:
          output: ${{ steps.report-filename.outputs.name }}
          image-ref: ${{ matrix.image }}
          skip-dirs: ${{ inputs.security-sca-exclude-dirs }}
          format: table
          exit-code: 1
          severity: CRITICAL,HIGH
          vuln-type: os,library
          ignore-unfixed: true
        env:
          TRIVY_USERNAME: ${{ vars.PLATFORM_REGISTRY_USER }}
          TRIVY_PASSWORD: ${{ secrets.PLATFORM_REGISTRY_PWD }}
        continue-on-error: true
      - name: Display SCA reports
        env:
          REPORT_FILENAME: ${{ steps.report-filename.outputs.name }}
        run: cat "${REPORT_FILENAME}"
      - name: Save SCA reports
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.report-filename.outputs.name }}
          path: ${{ steps.report-filename.outputs.name }}
      - name: Fail (or warn) if vulnerabilities found
        if: steps.scan.outcome == 'failure'
        env:
          FAIL_ENABLED: ${{ inputs.security-sca }}
        run: |
          echo "::WARNING::Security vulnerabilities have been detected via SCA scan" \
                "(see the SCA report artifact or step in the job for more details)"

          if [[ "${FAIL_ENABLED}" == true ]]; then
            exit 1
          fi
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  security-snyk-register:
    if: false
    runs-on: ubuntu-latest
    steps:
      - name: Check if the repository is already registered with Snyk
        id: registered
        env:
          REPO_NAME: ${{ github.event.repository.name}}
          REPO_OWNER: ${{ github.event.repository.owner.name }}
          SNYK_ORG_ID: ${{ secrets.PLATFORM_CI_SNYK_ORG_ID }}
          SNYK_TOKEN: ${{ secrets.PLATFORM_CI_SNYK_TOKEN }}
        run: |
          function exists_target {
            local registered_repos=$1

            target_id="$(
              jq -r \
                ".data[]
                | select(.attributes.display_name == \"$REPO_OWNER/$REPO_NAME\"
                and .relationships.integration.data.attributes.integration_type == \"github-cloud-app\")
                | .id" <<< "${registered_repos}"
            )"

            if [[ -n "${target_id}" ]]; then
              echo "Repository ${REPO_NAME} is already registered with Snyk - Target ID: ${target_id}"
              echo "target_id=${target_id}" >> "${GITHUB_OUTPUT}"
              exit 0
            fi
          }

          response="$(
            curl -sS -H "Authorization: token ${SNYK_TOKEN}" \
                     -H "Content-Type: application/json; charset=utf-8" \
                     -H "Accept: application/vnd.api+json" \
                     "https://api.snyk.io/rest/orgs/${SNYK_ORG_ID}/targets?version=2024-06-06"
          )"
          exists_target "${response}"

          next_url="$(jq -r '.links.next' <<< "${response}")"
          while [[ -n "${next_url}" && ${next_url} != 'null' ]]; do
            response="$(
              curl -sS -H "Authorization: token ${SNYK_TOKEN}" \
                       -H "Content-Type: application/json; charset=utf-8" \
                       -H "Accept: application/vnd.api+json" \
                       "https://api.snyk.io${next_url}"
            )"
            exists_target "${response}"
            next_url="$(jq -r '.links.next' <<< "${response}")"
          done
      - name: Register the new repository with Snyk
        if: steps.registered.outputs.target_id == ''
        env:
          GH_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
          REPO_NAME: ${{ github.event.repository.name}}
          REPO_OWNER: ${{ github.event.repository.owner.name }}
          SNYK_ORG_ID: ${{ secrets.PLATFORM_CI_SNYK_ORG_ID }}
          SNYK_INTEGRATION_ID: ${{ secrets.PLATFORM_CI_SNYK_INTEGRATION_ID }}
          SNYK_TOKEN: ${{ secrets.PLATFORM_CI_SNYK_TOKEN }}
        run: |
          default_branch="$(
            gh repo view "${REPO_OWNER}/${REPO_NAME}" --json defaultBranchRef -q '.defaultBranchRef.name'
          )"

          register_response="$(
            curl -sS -X POST -w "%{http_code}" \
              -H "Authorization: token ${SNYK_TOKEN}" \
              -H "Content-Type: application/json; charset=utf-8" \
              -d "{
                \"target\": {
                  \"owner\": \"${REPO_OWNER}\",
                  \"name\": \"${REPO_NAME}\",
                  \"branch\": \"${default_branch}\"
                }
              }" \
              "https://api.snyk.io/v1/org/${SNYK_ORG_ID}/integrations/${SNYK_INTEGRATION_ID}/import"
          )"

          if [[ "${register_response}" -ne 201 ]]; then
            echo "::ERROR::Failed to register repository ${REPO_NAME} with Snyk - HTTP Status: ${register_response}"
            exit 1
          fi

          echo "Repository ${REPO_NAME} has been registered with Snyk"
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  security-snyk-sca:
    needs: security-snyk-register
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Set up environment
        uses: uniphore/platform-github-actions/.github/actions/setup-env@main
        with:
          github-token: ${{ secrets.platform_ci_github_pull_token }}
      - name: Scan for tech stack
        uses: uniphore/platform-github-actions/.github/actions/detect-tech-stack@main
        id: stack
      - name: Cache Python dependencies
        if: steps.stack.outputs.python == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: ${{ runner.os }}-pip-
      - name: Install 3rd-party dependencies for Python project
        if: steps.stack.outputs.python == 'true'
        run: pip install -r requirements.txt
      - name: Make Gradle wrapper executable
        if: steps.stack.outputs.gradle == 'true'
        run: find . -name gradlew -exec chmod -v u+x {} +
      - name: Make Maven wrapper executable
        if: steps.stack.outputs.maven == 'true'
        run: find . -name mvnw -exec chmod -v u+x {} +
      - name: Check for vulnerabilities
        if: steps.stack.outputs.nodejs != 'true'
        uses: uniphore/platform-github-actions/.github/actions/snyk@main
        with:
          command: test
          fail-on-vulns: ${{ inputs.security-snyk }}
          monitor: monitor
          report-name: sca
          token: ${{ secrets.PLATFORM_CI_SNYK_TOKEN }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  security-snyk-sast:
    needs: security-snyk-register
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
      - name: Check for vulnerabilities
        uses: uniphore/platform-github-actions/.github/actions/snyk@main
        with:
          command: code test
          fail-on-vulns: ${{ inputs.security-snyk }}
          report-name: sast
          token: ${{ secrets.PLATFORM_CI_SNYK_TOKEN }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  security-snyk-container:
    if: >
      false
      && needs.build-image.result == 'success'
      && needs.build-collect.result == 'success'
      && needs.build-collect.outputs.container_modules_ids != '[]'
      && !cancelled()
    needs: [build-collect, build-image, security-snyk-register]
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.build-collect.outputs.container_modules_ids) }}
    runs-on: ubuntu-latest
    steps:
      - name: Set up Snyk
        uses: snyk/actions/setup@master
      - name: Login to Uniphore Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.platform_registry_host_url }}
          username: ${{ vars.platform_registry_read_only_user }}
          password: ${{ secrets.platform_registry_read_only_pwd }}
      - name: Generate report file name
        id: report-filename
        env:
          IMAGE_ID: ${{ matrix.image }}
        run: |
          image="${IMAGE_ID##*/}"
          image="${image//:/-}"
          echo "name=container-${image}" >> "${GITHUB_OUTPUT}"
      - name: Check for vulnerabilities
        uses: uniphore/platform-github-actions/.github/actions/snyk@main
        with:
          command: container test ${{ matrix.image }}
          fail-on-vulns: ${{ inputs.security-snyk }}
          monitor: container monitor ${{ matrix.image }}
          report-name: ${{ steps.report-filename.outputs.name }}
          token: ${{ secrets.PLATFORM_CI_SNYK_TOKEN }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  qa-sonarqube:
    if: >
      needs.security-chainguard.result == 'success'
      && needs.test-collect.result == 'success'
      && (needs.test-run.result == 'success' || needs.test-run.result == 'skipped')
      && !cancelled()
    needs: [test-collect, test-run, security-chainguard]
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
          submodules: true
          token: ${{ secrets.PLATFORM_CI_GITHUB_PULL_TOKEN }}
      - name: Set up environment
        uses: uniphore/platform-github-actions/.github/actions/setup-env@main
        with:
          github-token: ${{ secrets.platform_ci_github_pull_token }}
          github-pkg-token: ${{ secrets.platform_ci_github_packages_pull_token }}
      - name: Validate SonarQube Project Key
        env:
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          SONAR_CONFIGFILE='sonar-project.properties'

          if [[ -f "${SONAR_CONFIGFILE}" ]]; then
            project_name="$(grep 'sonar.projectName=' "${SONAR_CONFIGFILE}" | cut -d'=' -f2 || exit 0)"
            project_key="$(grep 'sonar.projectKey=' "${SONAR_CONFIGFILE}" | cut -d'=' -f2 || exit 0)"

            if [[ -n "${project_name}" && "${project_name}" != "${REPO_NAME}" ]]; then
              echo "::ERROR::Project name ${project_name} does not match the repository name ${REPO_NAME}"
              exit 1
            fi
            if [[ -n "${project_key}" && "${project_key}" != "${REPO_NAME}" ]]; then
              echo "::ERROR::Project key ${project_key} does not match the repository name ${REPO_NAME}"
              exit 1
            fi
          fi
      - name: Scan for tech stack
        uses: uniphore/platform-github-actions/.github/actions/detect-tech-stack@main
        id: stack
      - name: Download test reports
        uses: actions/download-artifact@v4
        with:
          path: test-reports
          pattern: test-reports-*
        continue-on-error: true
      - name: Inject properties for Go projects
        if: steps.stack.outputs.go == 'true'
        id: go
        run: |
          properties='-Dsonar.test.inclusions=**/*_test.go'
          echo "Injecting properties: ${properties}"
          echo "properties=${properties}" >> "${GITHUB_OUTPUT}"
      - name: Assign Custom Quality Profile for Chainguard Integrated Projects
        env:
          SONAR_CHAINGUARD_TOKEN: ${{ secrets.platform_sonar_chainguard_token }}
          SONAR_HOST_URL: ${{ vars.platform_sonar_host_url }}
          REPO_NAME: ${{ github.event.repository.name }}
          CHAINGUARD_INTEGRATED: ${{ needs.security-chainguard.outputs.integrated }}
          LANGUAGE: docker
          CUSTOM_QUALITY_PROFILE: Chainguard Docker Profile
        run: |
          if [[ "${CHAINGUARD_INTEGRATED}" == 'true' ]]; then
            action="add_project"
          else
            action="remove_project"
          fi

          http_code="$(
            curl -sS -X POST -w "%{http_code}" -u "${SONAR_CHAINGUARD_TOKEN}:" \
              -d "project=${REPO_NAME}" \
              -d "language=${LANGUAGE}" \
              -d "qualityProfile=${CUSTOM_QUALITY_PROFILE}" \
              "${SONAR_HOST_URL}/api/qualityprofiles/${action}"
          )"

          if [[ "${http_code}" -ne 204 ]]; then
            echo "::ERROR::Custom Quality Profile '${CUSTOM_QUALITY_PROFILE}' - failed to ${action/_project/} ${REPO_NAME} - HTTP Status: ${http_code}"
            exit 1
          fi
          echo "Custom Quality Profile '${CUSTOM_QUALITY_PROFILE}' - ${REPO_NAME} ${action/_project/ed}"
      - name: Scan for Sonar gradle plugin
        if: >
          steps.stack.outputs.java == 'true'
          && steps.stack.outputs.gradle == 'true'
        run: |
          SONAR_GRADLE_PLUGIN='org.sonarqube'
          GRADLE_SETTINGS_FILE='settings.gradle'
          GRADLE_DEFAULT_BUILD_FILE='build.gradle'

          if [[ -f "${GRADLE_SETTINGS_FILE}" ]]; then
            build_file="$(grep 'rootProject.buildFileName' "${GRADLE_SETTINGS_FILE}" | cut -d'=' -f2 | tr -d " '")" || true
          fi

          # Fallback to Default build file
          [[ -z "${build_file}" ]] && build_file="${GRADLE_DEFAULT_BUILD_FILE}"

          if [[ -f "${build_file}" ]]; then
            if ! grep -q -- "${SONAR_GRADLE_PLUGIN}" "${build_file}"; then
              echo "::ERROR file=${build_file}::SonarQube Gradle plugin is missing in the ${build_file} file. Please add the plugin for enabling SonarQube analysis"
              exit 1
            fi
          else
            echo "::ERROR::No ${build_file} file found in the top-root directory"
            exit 1
          fi
      - name: Run SonarQube Scanner for Java
        if: steps.stack.outputs.java == 'true'
        env:
          GITHUB_PKG_PULL_TOKEN: ${{ secrets.PLATFORM_CI_GITHUB_PACKAGES_PULL_TOKEN }}
          SONAR_TOKEN: ${{ secrets.platform_sonar_token }}
          SONAR_HOST_URL: ${{ vars.platform_sonar_host_url }}
          REPO_NAME: ${{ github.event.repository.name }}
          GRADLE: ${{ steps.stack.outputs.gradle }}
          MAVEN: ${{ steps.stack.outputs.maven }}
        run: |
          if [[ "${GRADLE}" == true ]]; then
            ./gradlew build
            ./gradlew sonar --info \
              -Dsonar.gradle.skipCompile=true \
              -Dsonar.projectKey="${REPO_NAME}" \
              -Dsonar.projectName="${REPO_NAME}"
          elif [[ "${MAVEN}" == true ]]; then
            mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
              -Dsonar.projectKey="${REPO_NAME}" \
              -Dsonar.projectName="${REPO_NAME}" \
              -DskipTests=true
          else
            echo "::ERROR::Java build tool not matching with Gradle or Maven"
            exit 1
          fi
      - name: Run SonarQube Scanner
        if: steps.stack.outputs.java != 'true'
        uses: sonarsource/sonarqube-scan-action@v1
        with:
          args: >
            -Dsonar.projectKey=${{ github.event.repository.name }}
            -Dsonar.python.version=3
            ${{ steps.go.outputs.properties }}
        env:
          SONAR_TOKEN: ${{ secrets.platform_sonar_token }}
          SONAR_HOST_URL: ${{ vars.platform_sonar_host_url }}
      - name: Find SonarQube report path
        id: sonar-report
        run: |
          report_path="$(find . -type f -name "report-task.txt" -print -quit)"
          echo "Found: ${report_path}"
          echo "report_path=${report_path}" >> "${GITHUB_OUTPUT}"
      - name: Assert Sonar Quality Gate
        if: inputs.sonarqube-quality-gate
        uses: sonarsource/sonarqube-quality-gate-action@f9fe214a5be5769c40619de2fff2726c36d2d5eb
        with:
          scanMetadataReportFile: ${{ steps.sonar-report.outputs.report_path }}
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.platform_sonar_token }}
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
  final:
    if: always()
    needs:
      - validate-yaml
      - validate-service-catalog
      - validate-collect-oas
      - validate-oas
      - validate-charts
      - validate-kyverno
      - test-collect
      - test-run
      - build-collect
      - build-image
      - security-chainguard
      - security-sca
      - security-snyk-register
      - security-snyk-sca
      - security-snyk-sast
      - security-snyk-container
      - qa-sonarqube
    runs-on: ubuntu-latest
    permissions:
      actions: read
      id-token: write
    steps:
      - name: Clean up cluster resources
        uses: uniphore/platform-github-actions/.github/actions/teardown-cluster@main
        with:
          aws-cluster-arn: ${{ vars.PLATFORM_CI_AWS_CLUSTER_ARN }}
          aws-iam-oidc-role-arn: ${{ vars.PLATFORM_CI_AWS_IAM_OIDC_ROLE_ARN }}
          aws-region: ${{ vars.PLATFORM_CI_AWS_REGION }}
      - name: Validate workflow conclusion
        uses: uniphore/platform-github-actions/.github/actions/workflow-conclusion@main
      - name: Debug mode
        if: failure() || runner.debug && always()
        uses: uniphore/platform-github-actions/.github/actions/debug@main
    timeout-minutes: 60
